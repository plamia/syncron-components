{"ast":null,"code":"'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar callBound = require('call-bind/callBound');\n\nvar $SyntaxError = GetIntrinsic('%SyntaxError%');\nvar getGlobalSymbolDescription = GetIntrinsic('%Symbol.keyFor%', true);\nvar thisSymbolValue = callBound('%Symbol.prototype.valueOf%', true);\nvar symToStr = callBound('Symbol.prototype.toString', true);\n\nvar getInferredName = require('./getInferredName');\n/* eslint-disable consistent-return */\n\n\nmodule.exports = callBound('%Symbol.prototype.description%', true) || function getSymbolDescription(symbol) {\n  if (!thisSymbolValue) {\n    throw new $SyntaxError('Symbols are not supported in this environment');\n  } // will throw if not a symbol primitive or wrapper object\n\n\n  var sym = thisSymbolValue(symbol);\n\n  if (getInferredName) {\n    var name = getInferredName(sym);\n\n    if (name === '') {\n      return;\n    }\n\n    return name.slice(1, -1); // name.slice('['.length, -']'.length);\n  }\n\n  var desc;\n\n  if (getGlobalSymbolDescription) {\n    desc = getGlobalSymbolDescription(sym);\n\n    if (typeof desc === 'string') {\n      return desc;\n    }\n  }\n\n  desc = symToStr(sym).slice(7, -1); // str.slice('Symbol('.length, -')'.length);\n\n  if (desc) {\n    return desc;\n  }\n};","map":{"version":3,"names":["GetIntrinsic","require","callBound","$SyntaxError","getGlobalSymbolDescription","thisSymbolValue","symToStr","getInferredName","module","exports","getSymbolDescription","symbol","sym","name","slice","desc"],"sources":["/Users/plamenakichukova/syncron-sdk-components/node_modules/get-symbol-description/index.js"],"sourcesContent":["'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar callBound = require('call-bind/callBound');\n\nvar $SyntaxError = GetIntrinsic('%SyntaxError%');\nvar getGlobalSymbolDescription = GetIntrinsic('%Symbol.keyFor%', true);\nvar thisSymbolValue = callBound('%Symbol.prototype.valueOf%', true);\nvar symToStr = callBound('Symbol.prototype.toString', true);\n\nvar getInferredName = require('./getInferredName');\n\n/* eslint-disable consistent-return */\nmodule.exports = callBound('%Symbol.prototype.description%', true) || function getSymbolDescription(symbol) {\n\tif (!thisSymbolValue) {\n\t\tthrow new $SyntaxError('Symbols are not supported in this environment');\n\t}\n\n\t// will throw if not a symbol primitive or wrapper object\n\tvar sym = thisSymbolValue(symbol);\n\n\tif (getInferredName) {\n\t\tvar name = getInferredName(sym);\n\t\tif (name === '') {\n\t\t\treturn;\n\t\t}\n\t\treturn name.slice(1, -1); // name.slice('['.length, -']'.length);\n\t}\n\n\tvar desc;\n\tif (getGlobalSymbolDescription) {\n\t\tdesc = getGlobalSymbolDescription(sym);\n\t\tif (typeof desc === 'string') {\n\t\t\treturn desc;\n\t\t}\n\t}\n\n\tdesc = symToStr(sym).slice(7, -1); // str.slice('Symbol('.length, -')'.length);\n\tif (desc) {\n\t\treturn desc;\n\t}\n};\n"],"mappings":"AAAA;;AAEA,IAAIA,YAAY,GAAGC,OAAO,CAAC,eAAD,CAA1B;;AAEA,IAAIC,SAAS,GAAGD,OAAO,CAAC,qBAAD,CAAvB;;AAEA,IAAIE,YAAY,GAAGH,YAAY,CAAC,eAAD,CAA/B;AACA,IAAII,0BAA0B,GAAGJ,YAAY,CAAC,iBAAD,EAAoB,IAApB,CAA7C;AACA,IAAIK,eAAe,GAAGH,SAAS,CAAC,4BAAD,EAA+B,IAA/B,CAA/B;AACA,IAAII,QAAQ,GAAGJ,SAAS,CAAC,2BAAD,EAA8B,IAA9B,CAAxB;;AAEA,IAAIK,eAAe,GAAGN,OAAO,CAAC,mBAAD,CAA7B;AAEA;;;AACAO,MAAM,CAACC,OAAP,GAAiBP,SAAS,CAAC,gCAAD,EAAmC,IAAnC,CAAT,IAAqD,SAASQ,oBAAT,CAA8BC,MAA9B,EAAsC;EAC3G,IAAI,CAACN,eAAL,EAAsB;IACrB,MAAM,IAAIF,YAAJ,CAAiB,+CAAjB,CAAN;EACA,CAH0G,CAK3G;;;EACA,IAAIS,GAAG,GAAGP,eAAe,CAACM,MAAD,CAAzB;;EAEA,IAAIJ,eAAJ,EAAqB;IACpB,IAAIM,IAAI,GAAGN,eAAe,CAACK,GAAD,CAA1B;;IACA,IAAIC,IAAI,KAAK,EAAb,EAAiB;MAChB;IACA;;IACD,OAAOA,IAAI,CAACC,KAAL,CAAW,CAAX,EAAc,CAAC,CAAf,CAAP,CALoB,CAKM;EAC1B;;EAED,IAAIC,IAAJ;;EACA,IAAIX,0BAAJ,EAAgC;IAC/BW,IAAI,GAAGX,0BAA0B,CAACQ,GAAD,CAAjC;;IACA,IAAI,OAAOG,IAAP,KAAgB,QAApB,EAA8B;MAC7B,OAAOA,IAAP;IACA;EACD;;EAEDA,IAAI,GAAGT,QAAQ,CAACM,GAAD,CAAR,CAAcE,KAAd,CAAoB,CAApB,EAAuB,CAAC,CAAxB,CAAP,CAxB2G,CAwBxE;;EACnC,IAAIC,IAAJ,EAAU;IACT,OAAOA,IAAP;EACA;AACD,CA5BD"},"metadata":{},"sourceType":"script"}