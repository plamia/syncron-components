{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport doctrine from 'doctrine';\n\nfunction containsJsDoc(value) {\n  return value != null && value.includes('@');\n}\n\nfunction parse(content, tags) {\n  var ast;\n\n  try {\n    ast = doctrine.parse(content, {\n      tags: tags,\n      sloppy: true\n    });\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.error(e);\n    throw new Error('Cannot parse JSDoc tags.');\n  }\n\n  return ast;\n}\n\nvar DEFAULT_OPTIONS = {\n  tags: ['param', 'arg', 'argument', 'returns', 'ignore']\n};\nexport var parseJsDoc = function parseJsDoc(value) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_OPTIONS;\n\n  if (!containsJsDoc(value)) {\n    return {\n      includesJsDoc: false,\n      ignore: false\n    };\n  }\n\n  var jsDocAst = parse(value, options.tags);\n  var extractedTags = extractJsDocTags(jsDocAst);\n\n  if (extractedTags.ignore) {\n    // There is no point in doing other stuff since this prop will not be rendered.\n    return {\n      includesJsDoc: true,\n      ignore: true\n    };\n  }\n\n  return {\n    includesJsDoc: true,\n    ignore: false,\n    // Always use the parsed description to ensure JSDoc is removed from the description.\n    description: jsDocAst.description,\n    extractedTags: extractedTags\n  };\n};\n\nfunction extractJsDocTags(ast) {\n  var extractedTags = {\n    params: null,\n    returns: null,\n    ignore: false\n  };\n\n  for (var i = 0; i < ast.tags.length; i += 1) {\n    var tag = ast.tags[i];\n\n    if (tag.title === 'ignore') {\n      extractedTags.ignore = true; // Once we reach an @ignore tag, there is no point in parsing the other tags since we will not render the prop.\n\n      break;\n    } else {\n      switch (tag.title) {\n        // arg & argument are aliases for param.\n        case 'param':\n        case 'arg':\n        case 'argument':\n          {\n            var paramTag = extractParam(tag);\n\n            if (paramTag != null) {\n              if (extractedTags.params == null) {\n                extractedTags.params = [];\n              }\n\n              extractedTags.params.push(paramTag);\n            }\n\n            break;\n          }\n\n        case 'returns':\n          {\n            var returnsTag = extractReturns(tag);\n\n            if (returnsTag != null) {\n              extractedTags.returns = returnsTag;\n            }\n\n            break;\n          }\n\n        default:\n          break;\n      }\n    }\n  }\n\n  return extractedTags;\n}\n\nfunction extractParam(tag) {\n  var paramName = tag.name; // When the @param doesn't have a name but have a type and a description, \"null-null\" is returned.\n\n  if (paramName != null && paramName !== 'null-null') {\n    return {\n      name: tag.name,\n      type: tag.type,\n      description: tag.description,\n      getPrettyName: function getPrettyName() {\n        if (paramName.includes('null')) {\n          // There is a few cases in which the returned param name contains \"null\".\n          // - @param {SyntheticEvent} event- Original SyntheticEvent\n          // - @param {SyntheticEvent} event.\\n@returns {string}\n          return paramName.replace('-null', '').replace('.null', '');\n        }\n\n        return tag.name;\n      },\n      getTypeName: function getTypeName() {\n        return tag.type != null ? extractTypeName(tag.type) : null;\n      }\n    };\n  }\n\n  return null;\n}\n\nfunction extractReturns(tag) {\n  if (tag.type != null) {\n    return {\n      type: tag.type,\n      description: tag.description,\n      getTypeName: function getTypeName() {\n        return extractTypeName(tag.type);\n      }\n    };\n  }\n\n  return null;\n}\n\nfunction extractTypeName(type) {\n  if (type.type === 'NameExpression') {\n    return type.name;\n  }\n\n  if (type.type === 'RecordType') {\n    var recordFields = type.fields.map(function (field) {\n      if (field.value != null) {\n        var valueTypeName = extractTypeName(field.value);\n        return \"\".concat(field.key, \": \").concat(valueTypeName);\n      }\n\n      return field.key;\n    });\n    return \"({\".concat(recordFields.join(', '), \"})\");\n  }\n\n  if (type.type === 'UnionType') {\n    var unionElements = type.elements.map(extractTypeName);\n    return \"(\".concat(unionElements.join('|'), \")\");\n  } // Only support untyped array: []. Might add more support later if required.\n\n\n  if (type.type === 'ArrayType') {\n    return '[]';\n  }\n\n  if (type.type === 'TypeApplication') {\n    if (type.expression != null) {\n      if (type.expression.name === 'Array') {\n        var arrayType = extractTypeName(type.applications[0]);\n        return \"\".concat(arrayType, \"[]\");\n      }\n    }\n  }\n\n  if (type.type === 'NullableType' || type.type === 'NonNullableType' || type.type === 'OptionalType') {\n    return extractTypeName(type.expression);\n  }\n\n  if (type.type === 'AllLiteral') {\n    return 'any';\n  }\n\n  return null;\n}","map":{"version":3,"names":["doctrine","containsJsDoc","value","includes","parse","content","tags","ast","sloppy","e","console","error","Error","DEFAULT_OPTIONS","parseJsDoc","options","arguments","length","undefined","includesJsDoc","ignore","jsDocAst","extractedTags","extractJsDocTags","description","params","returns","i","tag","title","paramTag","extractParam","push","returnsTag","extractReturns","paramName","name","type","getPrettyName","replace","getTypeName","extractTypeName","recordFields","fields","map","field","valueTypeName","concat","key","join","unionElements","elements","expression","arrayType","applications"],"sources":["/Users/plamenakichukova/syncron-sdk-components/node_modules/@storybook/docs-tools/dist/esm/argTypes/jsdocParser.js"],"sourcesContent":["import \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport doctrine from 'doctrine';\n\nfunction containsJsDoc(value) {\n  return value != null && value.includes('@');\n}\n\nfunction parse(content, tags) {\n  var ast;\n\n  try {\n    ast = doctrine.parse(content, {\n      tags: tags,\n      sloppy: true\n    });\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.error(e);\n    throw new Error('Cannot parse JSDoc tags.');\n  }\n\n  return ast;\n}\n\nvar DEFAULT_OPTIONS = {\n  tags: ['param', 'arg', 'argument', 'returns', 'ignore']\n};\nexport var parseJsDoc = function parseJsDoc(value) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_OPTIONS;\n\n  if (!containsJsDoc(value)) {\n    return {\n      includesJsDoc: false,\n      ignore: false\n    };\n  }\n\n  var jsDocAst = parse(value, options.tags);\n  var extractedTags = extractJsDocTags(jsDocAst);\n\n  if (extractedTags.ignore) {\n    // There is no point in doing other stuff since this prop will not be rendered.\n    return {\n      includesJsDoc: true,\n      ignore: true\n    };\n  }\n\n  return {\n    includesJsDoc: true,\n    ignore: false,\n    // Always use the parsed description to ensure JSDoc is removed from the description.\n    description: jsDocAst.description,\n    extractedTags: extractedTags\n  };\n};\n\nfunction extractJsDocTags(ast) {\n  var extractedTags = {\n    params: null,\n    returns: null,\n    ignore: false\n  };\n\n  for (var i = 0; i < ast.tags.length; i += 1) {\n    var tag = ast.tags[i];\n\n    if (tag.title === 'ignore') {\n      extractedTags.ignore = true; // Once we reach an @ignore tag, there is no point in parsing the other tags since we will not render the prop.\n\n      break;\n    } else {\n      switch (tag.title) {\n        // arg & argument are aliases for param.\n        case 'param':\n        case 'arg':\n        case 'argument':\n          {\n            var paramTag = extractParam(tag);\n\n            if (paramTag != null) {\n              if (extractedTags.params == null) {\n                extractedTags.params = [];\n              }\n\n              extractedTags.params.push(paramTag);\n            }\n\n            break;\n          }\n\n        case 'returns':\n          {\n            var returnsTag = extractReturns(tag);\n\n            if (returnsTag != null) {\n              extractedTags.returns = returnsTag;\n            }\n\n            break;\n          }\n\n        default:\n          break;\n      }\n    }\n  }\n\n  return extractedTags;\n}\n\nfunction extractParam(tag) {\n  var paramName = tag.name; // When the @param doesn't have a name but have a type and a description, \"null-null\" is returned.\n\n  if (paramName != null && paramName !== 'null-null') {\n    return {\n      name: tag.name,\n      type: tag.type,\n      description: tag.description,\n      getPrettyName: function getPrettyName() {\n        if (paramName.includes('null')) {\n          // There is a few cases in which the returned param name contains \"null\".\n          // - @param {SyntheticEvent} event- Original SyntheticEvent\n          // - @param {SyntheticEvent} event.\\n@returns {string}\n          return paramName.replace('-null', '').replace('.null', '');\n        }\n\n        return tag.name;\n      },\n      getTypeName: function getTypeName() {\n        return tag.type != null ? extractTypeName(tag.type) : null;\n      }\n    };\n  }\n\n  return null;\n}\n\nfunction extractReturns(tag) {\n  if (tag.type != null) {\n    return {\n      type: tag.type,\n      description: tag.description,\n      getTypeName: function getTypeName() {\n        return extractTypeName(tag.type);\n      }\n    };\n  }\n\n  return null;\n}\n\nfunction extractTypeName(type) {\n  if (type.type === 'NameExpression') {\n    return type.name;\n  }\n\n  if (type.type === 'RecordType') {\n    var recordFields = type.fields.map(function (field) {\n      if (field.value != null) {\n        var valueTypeName = extractTypeName(field.value);\n        return \"\".concat(field.key, \": \").concat(valueTypeName);\n      }\n\n      return field.key;\n    });\n    return \"({\".concat(recordFields.join(', '), \"})\");\n  }\n\n  if (type.type === 'UnionType') {\n    var unionElements = type.elements.map(extractTypeName);\n    return \"(\".concat(unionElements.join('|'), \")\");\n  } // Only support untyped array: []. Might add more support later if required.\n\n\n  if (type.type === 'ArrayType') {\n    return '[]';\n  }\n\n  if (type.type === 'TypeApplication') {\n    if (type.expression != null) {\n      if (type.expression.name === 'Array') {\n        var arrayType = extractTypeName(type.applications[0]);\n        return \"\".concat(arrayType, \"[]\");\n      }\n    }\n  }\n\n  if (type.type === 'NullableType' || type.type === 'NonNullableType' || type.type === 'OptionalType') {\n    return extractTypeName(type.expression);\n  }\n\n  if (type.type === 'AllLiteral') {\n    return 'any';\n  }\n\n  return null;\n}"],"mappings":"AAAA,OAAO,sCAAP;AACA,OAAO,uCAAP;AACA,OAAO,8BAAP;AACA,OAAO,0CAAP;AACA,OAAO,qCAAP;AACA,OAAO,mCAAP;AACA,OAAO,sCAAP;AACA,OAAO,iCAAP;AACA,OAAO,oCAAP;AACA,OAAO,kCAAP;AACA,OAAOA,QAAP,MAAqB,UAArB;;AAEA,SAASC,aAAT,CAAuBC,KAAvB,EAA8B;EAC5B,OAAOA,KAAK,IAAI,IAAT,IAAiBA,KAAK,CAACC,QAAN,CAAe,GAAf,CAAxB;AACD;;AAED,SAASC,KAAT,CAAeC,OAAf,EAAwBC,IAAxB,EAA8B;EAC5B,IAAIC,GAAJ;;EAEA,IAAI;IACFA,GAAG,GAAGP,QAAQ,CAACI,KAAT,CAAeC,OAAf,EAAwB;MAC5BC,IAAI,EAAEA,IADsB;MAE5BE,MAAM,EAAE;IAFoB,CAAxB,CAAN;EAID,CALD,CAKE,OAAOC,CAAP,EAAU;IACV;IACAC,OAAO,CAACC,KAAR,CAAcF,CAAd;IACA,MAAM,IAAIG,KAAJ,CAAU,0BAAV,CAAN;EACD;;EAED,OAAOL,GAAP;AACD;;AAED,IAAIM,eAAe,GAAG;EACpBP,IAAI,EAAE,CAAC,OAAD,EAAU,KAAV,EAAiB,UAAjB,EAA6B,SAA7B,EAAwC,QAAxC;AADc,CAAtB;AAGA,OAAO,IAAIQ,UAAU,GAAG,SAASA,UAAT,CAAoBZ,KAApB,EAA2B;EACjD,IAAIa,OAAO,GAAGC,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoEH,eAAlF;;EAEA,IAAI,CAACZ,aAAa,CAACC,KAAD,CAAlB,EAA2B;IACzB,OAAO;MACLiB,aAAa,EAAE,KADV;MAELC,MAAM,EAAE;IAFH,CAAP;EAID;;EAED,IAAIC,QAAQ,GAAGjB,KAAK,CAACF,KAAD,EAAQa,OAAO,CAACT,IAAhB,CAApB;EACA,IAAIgB,aAAa,GAAGC,gBAAgB,CAACF,QAAD,CAApC;;EAEA,IAAIC,aAAa,CAACF,MAAlB,EAA0B;IACxB;IACA,OAAO;MACLD,aAAa,EAAE,IADV;MAELC,MAAM,EAAE;IAFH,CAAP;EAID;;EAED,OAAO;IACLD,aAAa,EAAE,IADV;IAELC,MAAM,EAAE,KAFH;IAGL;IACAI,WAAW,EAAEH,QAAQ,CAACG,WAJjB;IAKLF,aAAa,EAAEA;EALV,CAAP;AAOD,CA5BM;;AA8BP,SAASC,gBAAT,CAA0BhB,GAA1B,EAA+B;EAC7B,IAAIe,aAAa,GAAG;IAClBG,MAAM,EAAE,IADU;IAElBC,OAAO,EAAE,IAFS;IAGlBN,MAAM,EAAE;EAHU,CAApB;;EAMA,KAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGpB,GAAG,CAACD,IAAJ,CAASW,MAA7B,EAAqCU,CAAC,IAAI,CAA1C,EAA6C;IAC3C,IAAIC,GAAG,GAAGrB,GAAG,CAACD,IAAJ,CAASqB,CAAT,CAAV;;IAEA,IAAIC,GAAG,CAACC,KAAJ,KAAc,QAAlB,EAA4B;MAC1BP,aAAa,CAACF,MAAd,GAAuB,IAAvB,CAD0B,CACG;;MAE7B;IACD,CAJD,MAIO;MACL,QAAQQ,GAAG,CAACC,KAAZ;QACE;QACA,KAAK,OAAL;QACA,KAAK,KAAL;QACA,KAAK,UAAL;UACE;YACE,IAAIC,QAAQ,GAAGC,YAAY,CAACH,GAAD,CAA3B;;YAEA,IAAIE,QAAQ,IAAI,IAAhB,EAAsB;cACpB,IAAIR,aAAa,CAACG,MAAd,IAAwB,IAA5B,EAAkC;gBAChCH,aAAa,CAACG,MAAd,GAAuB,EAAvB;cACD;;cAEDH,aAAa,CAACG,MAAd,CAAqBO,IAArB,CAA0BF,QAA1B;YACD;;YAED;UACD;;QAEH,KAAK,SAAL;UACE;YACE,IAAIG,UAAU,GAAGC,cAAc,CAACN,GAAD,CAA/B;;YAEA,IAAIK,UAAU,IAAI,IAAlB,EAAwB;cACtBX,aAAa,CAACI,OAAd,GAAwBO,UAAxB;YACD;;YAED;UACD;;QAEH;UACE;MA/BJ;IAiCD;EACF;;EAED,OAAOX,aAAP;AACD;;AAED,SAASS,YAAT,CAAsBH,GAAtB,EAA2B;EACzB,IAAIO,SAAS,GAAGP,GAAG,CAACQ,IAApB,CADyB,CACC;;EAE1B,IAAID,SAAS,IAAI,IAAb,IAAqBA,SAAS,KAAK,WAAvC,EAAoD;IAClD,OAAO;MACLC,IAAI,EAAER,GAAG,CAACQ,IADL;MAELC,IAAI,EAAET,GAAG,CAACS,IAFL;MAGLb,WAAW,EAAEI,GAAG,CAACJ,WAHZ;MAILc,aAAa,EAAE,SAASA,aAAT,GAAyB;QACtC,IAAIH,SAAS,CAAChC,QAAV,CAAmB,MAAnB,CAAJ,EAAgC;UAC9B;UACA;UACA;UACA,OAAOgC,SAAS,CAACI,OAAV,CAAkB,OAAlB,EAA2B,EAA3B,EAA+BA,OAA/B,CAAuC,OAAvC,EAAgD,EAAhD,CAAP;QACD;;QAED,OAAOX,GAAG,CAACQ,IAAX;MACD,CAbI;MAcLI,WAAW,EAAE,SAASA,WAAT,GAAuB;QAClC,OAAOZ,GAAG,CAACS,IAAJ,IAAY,IAAZ,GAAmBI,eAAe,CAACb,GAAG,CAACS,IAAL,CAAlC,GAA+C,IAAtD;MACD;IAhBI,CAAP;EAkBD;;EAED,OAAO,IAAP;AACD;;AAED,SAASH,cAAT,CAAwBN,GAAxB,EAA6B;EAC3B,IAAIA,GAAG,CAACS,IAAJ,IAAY,IAAhB,EAAsB;IACpB,OAAO;MACLA,IAAI,EAAET,GAAG,CAACS,IADL;MAELb,WAAW,EAAEI,GAAG,CAACJ,WAFZ;MAGLgB,WAAW,EAAE,SAASA,WAAT,GAAuB;QAClC,OAAOC,eAAe,CAACb,GAAG,CAACS,IAAL,CAAtB;MACD;IALI,CAAP;EAOD;;EAED,OAAO,IAAP;AACD;;AAED,SAASI,eAAT,CAAyBJ,IAAzB,EAA+B;EAC7B,IAAIA,IAAI,CAACA,IAAL,KAAc,gBAAlB,EAAoC;IAClC,OAAOA,IAAI,CAACD,IAAZ;EACD;;EAED,IAAIC,IAAI,CAACA,IAAL,KAAc,YAAlB,EAAgC;IAC9B,IAAIK,YAAY,GAAGL,IAAI,CAACM,MAAL,CAAYC,GAAZ,CAAgB,UAAUC,KAAV,EAAiB;MAClD,IAAIA,KAAK,CAAC3C,KAAN,IAAe,IAAnB,EAAyB;QACvB,IAAI4C,aAAa,GAAGL,eAAe,CAACI,KAAK,CAAC3C,KAAP,CAAnC;QACA,OAAO,GAAG6C,MAAH,CAAUF,KAAK,CAACG,GAAhB,EAAqB,IAArB,EAA2BD,MAA3B,CAAkCD,aAAlC,CAAP;MACD;;MAED,OAAOD,KAAK,CAACG,GAAb;IACD,CAPkB,CAAnB;IAQA,OAAO,KAAKD,MAAL,CAAYL,YAAY,CAACO,IAAb,CAAkB,IAAlB,CAAZ,EAAqC,IAArC,CAAP;EACD;;EAED,IAAIZ,IAAI,CAACA,IAAL,KAAc,WAAlB,EAA+B;IAC7B,IAAIa,aAAa,GAAGb,IAAI,CAACc,QAAL,CAAcP,GAAd,CAAkBH,eAAlB,CAApB;IACA,OAAO,IAAIM,MAAJ,CAAWG,aAAa,CAACD,IAAd,CAAmB,GAAnB,CAAX,EAAoC,GAApC,CAAP;EACD,CApB4B,CAoB3B;;;EAGF,IAAIZ,IAAI,CAACA,IAAL,KAAc,WAAlB,EAA+B;IAC7B,OAAO,IAAP;EACD;;EAED,IAAIA,IAAI,CAACA,IAAL,KAAc,iBAAlB,EAAqC;IACnC,IAAIA,IAAI,CAACe,UAAL,IAAmB,IAAvB,EAA6B;MAC3B,IAAIf,IAAI,CAACe,UAAL,CAAgBhB,IAAhB,KAAyB,OAA7B,EAAsC;QACpC,IAAIiB,SAAS,GAAGZ,eAAe,CAACJ,IAAI,CAACiB,YAAL,CAAkB,CAAlB,CAAD,CAA/B;QACA,OAAO,GAAGP,MAAH,CAAUM,SAAV,EAAqB,IAArB,CAAP;MACD;IACF;EACF;;EAED,IAAIhB,IAAI,CAACA,IAAL,KAAc,cAAd,IAAgCA,IAAI,CAACA,IAAL,KAAc,iBAA9C,IAAmEA,IAAI,CAACA,IAAL,KAAc,cAArF,EAAqG;IACnG,OAAOI,eAAe,CAACJ,IAAI,CAACe,UAAN,CAAtB;EACD;;EAED,IAAIf,IAAI,CAACA,IAAL,KAAc,YAAlB,EAAgC;IAC9B,OAAO,KAAP;EACD;;EAED,OAAO,IAAP;AACD"},"metadata":{},"sourceType":"module"}