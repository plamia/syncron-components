{"ast":null,"code":"\"use strict\";\n/* eslint-disable no-underscore-dangle */\n\n/* global window */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extractComponentDescription = exports.extractArgTypes = exports.extractArgTypesFromData = exports.extractType = exports.findComponentByName = exports.checkValidCompodocJson = exports.checkValidComponentOrDirective = exports.getCompodocJson = exports.setCompodocJson = exports.isMethod = void 0;\n\nconst client_logger_1 = require(\"@storybook/client-logger\");\n\nexports.isMethod = methodOrProp => {\n  return methodOrProp.args !== undefined;\n};\n\nexports.setCompodocJson = compodocJson => {\n  // @ts-ignore\n  window.__STORYBOOK_COMPODOC_JSON__ = compodocJson;\n}; // @ts-ignore\n\n\nexports.getCompodocJson = () => window.__STORYBOOK_COMPODOC_JSON__;\n\nexports.checkValidComponentOrDirective = component => {\n  if (!component.name) {\n    throw new Error(`Invalid component ${JSON.stringify(component)}`);\n  }\n};\n\nexports.checkValidCompodocJson = compodocJson => {\n  if (!compodocJson || !compodocJson.components) {\n    throw new Error('Invalid compodoc JSON');\n  }\n};\n\nconst hasDecorator = (item, decoratorName) => item.decorators && item.decorators.find(x => x.name === decoratorName);\n\nconst mapPropertyToSection = item => {\n  if (hasDecorator(item, 'ViewChild')) {\n    return 'view child';\n  }\n\n  if (hasDecorator(item, 'ViewChildren')) {\n    return 'view children';\n  }\n\n  if (hasDecorator(item, 'ContentChild')) {\n    return 'content child';\n  }\n\n  if (hasDecorator(item, 'ContentChildren')) {\n    return 'content children';\n  }\n\n  return 'properties';\n};\n\nconst mapItemToSection = (key, item) => {\n  switch (key) {\n    case 'methods':\n    case 'methodsClass':\n      return 'methods';\n\n    case 'inputsClass':\n      return 'inputs';\n\n    case 'outputsClass':\n      return 'outputs';\n\n    case 'properties':\n    case 'propertiesClass':\n      if (exports.isMethod(item)) {\n        throw new Error(\"Cannot be of type Method if key === 'propertiesClass'\");\n      }\n\n      return mapPropertyToSection(item);\n\n    default:\n      throw new Error(`Unknown key: ${key}`);\n  }\n};\n\nexports.findComponentByName = (name, compodocJson) => compodocJson.components.find(c => c.name === name) || compodocJson.directives.find(c => c.name === name) || compodocJson.pipes.find(c => c.name === name) || compodocJson.injectables.find(c => c.name === name) || compodocJson.classes.find(c => c.name === name);\n\nconst getComponentData = component => {\n  if (!component) {\n    return null;\n  }\n\n  exports.checkValidComponentOrDirective(component);\n  const compodocJson = exports.getCompodocJson();\n\n  if (!compodocJson) {\n    return null;\n  }\n\n  exports.checkValidCompodocJson(compodocJson);\n  const {\n    name\n  } = component;\n  const metadata = exports.findComponentByName(name, compodocJson);\n\n  if (!metadata) {\n    client_logger_1.logger.warn(`Component not found in compodoc JSON: '${name}'`);\n  }\n\n  return metadata;\n};\n\nconst displaySignature = item => {\n  const args = item.args.map(arg => `${arg.name}${arg.optional ? '?' : ''}: ${arg.type}`);\n  return `(${args.join(', ')}) => ${item.returnType}`;\n};\n\nconst extractTypeFromValue = defaultValue => {\n  const valueType = typeof defaultValue;\n  return defaultValue || valueType === 'number' || valueType === 'boolean' || valueType === 'string' ? valueType : null;\n};\n\nconst extractEnumValues = compodocType => {\n  var _a, _b;\n\n  const compodocJson = exports.getCompodocJson();\n  const enumType = (_b = (_a = compodocJson === null || compodocJson === void 0 ? void 0 : compodocJson.miscellaneous) === null || _a === void 0 ? void 0 : _a.enumerations) === null || _b === void 0 ? void 0 : _b.find(x => x.name === compodocType);\n\n  if (enumType === null || enumType === void 0 ? void 0 : enumType.childs.every(x => x.value)) {\n    return enumType.childs.map(x => x.value);\n  }\n\n  if (typeof compodocType !== 'string' || compodocType.indexOf('|') === -1) {\n    return null;\n  }\n\n  try {\n    return compodocType.split('|').map(value => JSON.parse(value));\n  } catch (e) {\n    return null;\n  }\n};\n\nexports.extractType = (property, defaultValue) => {\n  const compodocType = property.type || extractTypeFromValue(defaultValue);\n\n  switch (compodocType) {\n    case 'string':\n    case 'boolean':\n    case 'number':\n      return {\n        name: compodocType\n      };\n\n    case undefined:\n    case null:\n      return {\n        name: 'void'\n      };\n\n    default:\n      {\n        const resolvedType = resolveTypealias(compodocType);\n        const enumValues = extractEnumValues(resolvedType);\n        return enumValues ? {\n          name: 'enum',\n          value: enumValues\n        } : {\n          name: 'object'\n        };\n      }\n  }\n};\n\nconst castDefaultValue = (property, defaultValue) => {\n  const compodocType = property.type; // All these checks are necessary as compodoc does not always set the type ie. @HostBinding have empty types.\n  // null and undefined also have 'any' type\n\n  if (['boolean', 'number', 'string', 'EventEmitter'].includes(compodocType)) {\n    switch (compodocType) {\n      case 'boolean':\n        return defaultValue === 'true';\n\n      case 'number':\n        return Number(defaultValue);\n\n      case 'EventEmitter':\n        return undefined;\n\n      default:\n        return defaultValue;\n    }\n  } else {\n    switch (defaultValue) {\n      case 'true':\n        return true;\n\n      case 'false':\n        return false;\n\n      case 'null':\n        return null;\n\n      case 'undefined':\n        return undefined;\n\n      default:\n        return defaultValue;\n    }\n  }\n};\n\nconst extractDefaultValueFromComments = (property, value) => {\n  let commentValue = value;\n  property.jsdoctags.forEach(tag => {\n    if (['default', 'defaultvalue'].includes(tag.tagName.escapedText)) {\n      // @ts-ignore\n      const dom = new window.DOMParser().parseFromString(tag.comment, 'text/html');\n      commentValue = dom.body.textContent;\n    }\n  });\n  return commentValue;\n};\n\nconst extractDefaultValue = property => {\n  var _a, _b;\n\n  try {\n    let value = (_a = property.defaultValue) === null || _a === void 0 ? void 0 : _a.replace(/^'(.*)'$/, '$1');\n    value = castDefaultValue(property, value);\n\n    if (value == null && ((_b = property.jsdoctags) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n      value = extractDefaultValueFromComments(property, value);\n    }\n\n    return value;\n  } catch (err) {\n    client_logger_1.logger.debug(`Error extracting ${property.name}: ${property.defaultValue}`);\n    return undefined;\n  }\n};\n\nconst resolveTypealias = compodocType => {\n  var _a, _b;\n\n  const compodocJson = exports.getCompodocJson();\n  const typeAlias = (_b = (_a = compodocJson === null || compodocJson === void 0 ? void 0 : compodocJson.miscellaneous) === null || _a === void 0 ? void 0 : _a.typealiases) === null || _b === void 0 ? void 0 : _b.find(x => x.name === compodocType);\n  return typeAlias ? resolveTypealias(typeAlias.rawtype) : compodocType;\n};\n\nexports.extractArgTypesFromData = componentData => {\n  const sectionToItems = {};\n  const compodocClasses = ['component', 'directive'].includes(componentData.type) ? ['propertiesClass', 'methodsClass', 'inputsClass', 'outputsClass'] : ['properties', 'methods'];\n  compodocClasses.forEach(key => {\n    const data = componentData[key] || [];\n    data.forEach(item => {\n      const section = mapItemToSection(key, item);\n      const defaultValue = exports.isMethod(item) ? undefined : extractDefaultValue(item);\n      const type = exports.isMethod(item) || section !== 'inputs' && section !== 'properties' ? {\n        name: 'void'\n      } : exports.extractType(item, defaultValue);\n      const action = section === 'outputs' ? {\n        action: item.name\n      } : {};\n      const argType = Object.assign(Object.assign({\n        name: item.name,\n        description: item.rawdescription || item.description,\n        defaultValue,\n        type\n      }, action), {\n        table: {\n          category: section,\n          type: {\n            summary: exports.isMethod(item) ? displaySignature(item) : item.type,\n            required: exports.isMethod(item) ? false : !item.optional\n          },\n          defaultValue: {\n            summary: defaultValue\n          }\n        }\n      });\n\n      if (!sectionToItems[section]) {\n        sectionToItems[section] = [];\n      }\n\n      sectionToItems[section].push(argType);\n    });\n  });\n  const SECTIONS = ['properties', 'inputs', 'outputs', 'methods', 'view child', 'view children', 'content child', 'content children'];\n  const argTypes = {};\n  SECTIONS.forEach(section => {\n    const items = sectionToItems[section];\n\n    if (items) {\n      items.forEach(argType => {\n        argTypes[argType.name] = argType;\n      });\n    }\n  });\n  return argTypes;\n};\n\nexports.extractArgTypes = component => {\n  const componentData = getComponentData(component);\n  return componentData && exports.extractArgTypesFromData(componentData);\n};\n\nexports.extractComponentDescription = component => {\n  const componentData = getComponentData(component);\n  return componentData && (componentData.rawdescription || componentData.description);\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","extractComponentDescription","extractArgTypes","extractArgTypesFromData","extractType","findComponentByName","checkValidCompodocJson","checkValidComponentOrDirective","getCompodocJson","setCompodocJson","isMethod","client_logger_1","require","methodOrProp","args","undefined","compodocJson","window","__STORYBOOK_COMPODOC_JSON__","component","name","Error","JSON","stringify","components","hasDecorator","item","decoratorName","decorators","find","x","mapPropertyToSection","mapItemToSection","key","c","directives","pipes","injectables","classes","getComponentData","metadata","logger","warn","displaySignature","map","arg","optional","type","join","returnType","extractTypeFromValue","defaultValue","valueType","extractEnumValues","compodocType","_a","_b","enumType","miscellaneous","enumerations","childs","every","indexOf","split","parse","e","property","resolvedType","resolveTypealias","enumValues","castDefaultValue","includes","Number","extractDefaultValueFromComments","commentValue","jsdoctags","forEach","tag","tagName","escapedText","dom","DOMParser","parseFromString","comment","body","textContent","extractDefaultValue","replace","length","err","debug","typeAlias","typealiases","rawtype","componentData","sectionToItems","compodocClasses","data","section","action","argType","assign","description","rawdescription","table","category","summary","required","push","SECTIONS","argTypes","items"],"sources":["/Users/plamenakichukova/syncron-sdk-components/node_modules/@storybook/angular/dist/ts3.9/client/docs/compodoc.js"],"sourcesContent":["\"use strict\";\n/* eslint-disable no-underscore-dangle */\n/* global window */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extractComponentDescription = exports.extractArgTypes = exports.extractArgTypesFromData = exports.extractType = exports.findComponentByName = exports.checkValidCompodocJson = exports.checkValidComponentOrDirective = exports.getCompodocJson = exports.setCompodocJson = exports.isMethod = void 0;\nconst client_logger_1 = require(\"@storybook/client-logger\");\nexports.isMethod = (methodOrProp) => {\n    return methodOrProp.args !== undefined;\n};\nexports.setCompodocJson = (compodocJson) => {\n    // @ts-ignore\n    window.__STORYBOOK_COMPODOC_JSON__ = compodocJson;\n};\n// @ts-ignore\nexports.getCompodocJson = () => window.__STORYBOOK_COMPODOC_JSON__;\nexports.checkValidComponentOrDirective = (component) => {\n    if (!component.name) {\n        throw new Error(`Invalid component ${JSON.stringify(component)}`);\n    }\n};\nexports.checkValidCompodocJson = (compodocJson) => {\n    if (!compodocJson || !compodocJson.components) {\n        throw new Error('Invalid compodoc JSON');\n    }\n};\nconst hasDecorator = (item, decoratorName) => item.decorators && item.decorators.find((x) => x.name === decoratorName);\nconst mapPropertyToSection = (item) => {\n    if (hasDecorator(item, 'ViewChild')) {\n        return 'view child';\n    }\n    if (hasDecorator(item, 'ViewChildren')) {\n        return 'view children';\n    }\n    if (hasDecorator(item, 'ContentChild')) {\n        return 'content child';\n    }\n    if (hasDecorator(item, 'ContentChildren')) {\n        return 'content children';\n    }\n    return 'properties';\n};\nconst mapItemToSection = (key, item) => {\n    switch (key) {\n        case 'methods':\n        case 'methodsClass':\n            return 'methods';\n        case 'inputsClass':\n            return 'inputs';\n        case 'outputsClass':\n            return 'outputs';\n        case 'properties':\n        case 'propertiesClass':\n            if (exports.isMethod(item)) {\n                throw new Error(\"Cannot be of type Method if key === 'propertiesClass'\");\n            }\n            return mapPropertyToSection(item);\n        default:\n            throw new Error(`Unknown key: ${key}`);\n    }\n};\nexports.findComponentByName = (name, compodocJson) => compodocJson.components.find((c) => c.name === name) ||\n    compodocJson.directives.find((c) => c.name === name) ||\n    compodocJson.pipes.find((c) => c.name === name) ||\n    compodocJson.injectables.find((c) => c.name === name) ||\n    compodocJson.classes.find((c) => c.name === name);\nconst getComponentData = (component) => {\n    if (!component) {\n        return null;\n    }\n    exports.checkValidComponentOrDirective(component);\n    const compodocJson = exports.getCompodocJson();\n    if (!compodocJson) {\n        return null;\n    }\n    exports.checkValidCompodocJson(compodocJson);\n    const { name } = component;\n    const metadata = exports.findComponentByName(name, compodocJson);\n    if (!metadata) {\n        client_logger_1.logger.warn(`Component not found in compodoc JSON: '${name}'`);\n    }\n    return metadata;\n};\nconst displaySignature = (item) => {\n    const args = item.args.map((arg) => `${arg.name}${arg.optional ? '?' : ''}: ${arg.type}`);\n    return `(${args.join(', ')}) => ${item.returnType}`;\n};\nconst extractTypeFromValue = (defaultValue) => {\n    const valueType = typeof defaultValue;\n    return defaultValue || valueType === 'number' || valueType === 'boolean' || valueType === 'string'\n        ? valueType\n        : null;\n};\nconst extractEnumValues = (compodocType) => {\n    var _a, _b;\n    const compodocJson = exports.getCompodocJson();\n    const enumType = (_b = (_a = compodocJson === null || compodocJson === void 0 ? void 0 : compodocJson.miscellaneous) === null || _a === void 0 ? void 0 : _a.enumerations) === null || _b === void 0 ? void 0 : _b.find((x) => x.name === compodocType);\n    if (enumType === null || enumType === void 0 ? void 0 : enumType.childs.every((x) => x.value)) {\n        return enumType.childs.map((x) => x.value);\n    }\n    if (typeof compodocType !== 'string' || compodocType.indexOf('|') === -1) {\n        return null;\n    }\n    try {\n        return compodocType.split('|').map((value) => JSON.parse(value));\n    }\n    catch (e) {\n        return null;\n    }\n};\nexports.extractType = (property, defaultValue) => {\n    const compodocType = property.type || extractTypeFromValue(defaultValue);\n    switch (compodocType) {\n        case 'string':\n        case 'boolean':\n        case 'number':\n            return { name: compodocType };\n        case undefined:\n        case null:\n            return { name: 'void' };\n        default: {\n            const resolvedType = resolveTypealias(compodocType);\n            const enumValues = extractEnumValues(resolvedType);\n            return enumValues ? { name: 'enum', value: enumValues } : { name: 'object' };\n        }\n    }\n};\nconst castDefaultValue = (property, defaultValue) => {\n    const compodocType = property.type;\n    // All these checks are necessary as compodoc does not always set the type ie. @HostBinding have empty types.\n    // null and undefined also have 'any' type\n    if (['boolean', 'number', 'string', 'EventEmitter'].includes(compodocType)) {\n        switch (compodocType) {\n            case 'boolean':\n                return defaultValue === 'true';\n            case 'number':\n                return Number(defaultValue);\n            case 'EventEmitter':\n                return undefined;\n            default:\n                return defaultValue;\n        }\n    }\n    else {\n        switch (defaultValue) {\n            case 'true':\n                return true;\n            case 'false':\n                return false;\n            case 'null':\n                return null;\n            case 'undefined':\n                return undefined;\n            default:\n                return defaultValue;\n        }\n    }\n};\nconst extractDefaultValueFromComments = (property, value) => {\n    let commentValue = value;\n    property.jsdoctags.forEach((tag) => {\n        if (['default', 'defaultvalue'].includes(tag.tagName.escapedText)) {\n            // @ts-ignore\n            const dom = new window.DOMParser().parseFromString(tag.comment, 'text/html');\n            commentValue = dom.body.textContent;\n        }\n    });\n    return commentValue;\n};\nconst extractDefaultValue = (property) => {\n    var _a, _b;\n    try {\n        let value = (_a = property.defaultValue) === null || _a === void 0 ? void 0 : _a.replace(/^'(.*)'$/, '$1');\n        value = castDefaultValue(property, value);\n        if (value == null && ((_b = property.jsdoctags) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n            value = extractDefaultValueFromComments(property, value);\n        }\n        return value;\n    }\n    catch (err) {\n        client_logger_1.logger.debug(`Error extracting ${property.name}: ${property.defaultValue}`);\n        return undefined;\n    }\n};\nconst resolveTypealias = (compodocType) => {\n    var _a, _b;\n    const compodocJson = exports.getCompodocJson();\n    const typeAlias = (_b = (_a = compodocJson === null || compodocJson === void 0 ? void 0 : compodocJson.miscellaneous) === null || _a === void 0 ? void 0 : _a.typealiases) === null || _b === void 0 ? void 0 : _b.find((x) => x.name === compodocType);\n    return typeAlias ? resolveTypealias(typeAlias.rawtype) : compodocType;\n};\nexports.extractArgTypesFromData = (componentData) => {\n    const sectionToItems = {};\n    const compodocClasses = ['component', 'directive'].includes(componentData.type)\n        ? ['propertiesClass', 'methodsClass', 'inputsClass', 'outputsClass']\n        : ['properties', 'methods'];\n    compodocClasses.forEach((key) => {\n        const data = componentData[key] || [];\n        data.forEach((item) => {\n            const section = mapItemToSection(key, item);\n            const defaultValue = exports.isMethod(item) ? undefined : extractDefaultValue(item);\n            const type = exports.isMethod(item) || (section !== 'inputs' && section !== 'properties')\n                ? { name: 'void' }\n                : exports.extractType(item, defaultValue);\n            const action = section === 'outputs' ? { action: item.name } : {};\n            const argType = Object.assign(Object.assign({ name: item.name, description: item.rawdescription || item.description, defaultValue,\n                type }, action), { table: {\n                    category: section,\n                    type: {\n                        summary: exports.isMethod(item) ? displaySignature(item) : item.type,\n                        required: exports.isMethod(item) ? false : !item.optional,\n                    },\n                    defaultValue: { summary: defaultValue },\n                } });\n            if (!sectionToItems[section]) {\n                sectionToItems[section] = [];\n            }\n            sectionToItems[section].push(argType);\n        });\n    });\n    const SECTIONS = [\n        'properties',\n        'inputs',\n        'outputs',\n        'methods',\n        'view child',\n        'view children',\n        'content child',\n        'content children',\n    ];\n    const argTypes = {};\n    SECTIONS.forEach((section) => {\n        const items = sectionToItems[section];\n        if (items) {\n            items.forEach((argType) => {\n                argTypes[argType.name] = argType;\n            });\n        }\n    });\n    return argTypes;\n};\nexports.extractArgTypes = (component) => {\n    const componentData = getComponentData(component);\n    return componentData && exports.extractArgTypesFromData(componentData);\n};\nexports.extractComponentDescription = (component) => {\n    const componentData = getComponentData(component);\n    return componentData && (componentData.rawdescription || componentData.description);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}